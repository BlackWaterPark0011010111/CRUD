# CRUD
sqlalchemy
curl
fast api

это способ создания нашего приложения с помощью Create Read Update Delete операций. то есть он должен уметь создавать,читать,обновлять и удалять состав
данных.   это структурирование наших моделей для наших API.Оперирование  в стиле CRUD в базе данных и для всех наших существующих вычислительных
сущностей. CRUD соответствует http- методам которые используются  чтобы сообщить нашему серверу как и что мы хотим сделать с нашим хранилищем в базе, и как
мы хотим взаимодействовать с веб-сайтом:

Создать  :  POST
Читать   :  GET
Обновить :  UPDATE
Удалить  :  DELETE

Наше API,которое хранит данные должно позволять нам добавлять новые записи по тому скелету,которое мы задаем в нашей базе.

в записи curl -X POST http://localhost:5000 /add -d name=Jack -d price=10---- в этой записи "-Х" --это структурирование нашего запроса как запрос POST, а флаги "-d" --это сами данные которые мы отправляем в наше API. и это возвращает запись с нашими данными в формате json.


READ: позволяет просто увидеть все данные которые у нас есть в данную секунду без внесений каких либо изменений.
curl -X GET http://localhost:5000 /drinks

{ 
    "drinks":[
        {
            "id": 1
            "name":"Jack",
            "price":10
        },
        {
            "id": 2
            "name":"Jim",
            "price":10  
        }
    ]
}

curl -X GET http://localhost:5000 /drinks/1    ----  1-ца здесь выводит то, что содержит идентификатор id равен 1.

то есть если мы с read просто прописываем название url без идентификатора,но в read нам уже нужен id по которому мы будем смотреть и читать то,что нам
нужно вытащить.
все наши сущности внутри системы они будет проходить путь через цепочку последовательностей определенных стадий. и каждая стадия будет состоянием на тот
выбранный момент времени. и CRUD помогает управлять переходами между состояниями 
через POST, через специальный метод http, мы создаем новые записи для внесения их в дб

sqlalchemy- это непосредственно работа с бд.

CRUD - чистое бизнес-событие.они редко бывают изолированными и их нельзя рассматривать изолированно.все проверки с правами доступа должны быть на уровне
api и бд.если злоумышленник найдет способ отправить запрос в api,сможет удалить то что не должен,нужна row-level security, принцип defense in depth. это
разделение ответственностей.
это отдельная архитектура с 4-мя endpoint`ами.оно должно быть идемпотентным.
каждая crud операция должна отображать грань намерения,если при UPDATE идет исправление опечатки,то это не должно влечь за собой полную замену документа
или при обновлении аватара(только через узкий endpoint PATCH/user/{id}/avatar),не отправлять в изменение весь профиль.это только через узкий endpoint
через дизайн API.
Каналы утечки бизнес-логики по выстроенным endpoint`ам,ихние поля и какие обязательны к заполнению а какие нет  
API-это как публичная декларация о том как устроен мой бизнес и каждый endpoint и поле в схеме это будет поводом утечки информации. и изучив мою openAPI-
спецификацию,составить карту внутренностей,всех процессов.
к Примеру:
поле  status обязательное  и при создании принимает значения:
"new", "cooking", "on_way", "delivered", "cancelled"
cancelled - это side-ветка.может выйти из new или cooking.
И уязвимость поля status,поскольку оно обязательное при создании,можно создать сущность status: "delivered" и сразу получить заказ,минуя кухню и курьера.
и система принимающая такой запрос,она либо совершает ошибку либо вынуждена ставить костыли. 
если создание заказа будет через POST/orders,где user_id будет браться из токена а цена и статус (status = "pending_payment")будет вычисляться
на сервере.после проверки ресторана и позиции в меню и акции и при ошибке возвращает валидацию. пока статус "pending_payment" заказ будет существовать,но
не подтвержден и ждемс оплату или отмену. при успешной оплате клиент вызывает POST /orders/{id}/confirm-payment и бэкенд меняет статус на accepted, если
ресторан открыт или на "new" если нужно дождаться ответа от ресторана.
если отменяем заказ -->POST /orders/{id}/confirm-payment  ---> переводим в статус cancelled и сохраняется опциональная причина в логах,переводится в поле
reason.для внутренних переходов статусов используем POST /orders/{id}/status- он будет endpoint`ом доступным только для ресторана или админов и выполнять
переходы только по описанному workflow. вся линейная цепочка не выставлена наружу и больше не очевидна,и видны не состояния а действия.сама машина
состояний инкапсулирована внутри бэкенда в сервис-слое. Поля которые система определяет сама как status,total_price,final_priceБне будут приниматься от
клиента. все критически действия по созданию,подтверждению,отмене или смене статуса будут проверятся  авторизацией,валидностью состояния и будут
идемпотентными по возможности,чтобы при создании повторного вызова не создавали конфликтов. 

Сама экономика CRUD
READ-самая дешевая но и самая частая.максимальная оптимизация,кешируемость и масштабность.
CREATE и UPDATE -дорогие,меняют истину,исполнять атомарно и ограничивать количество бизнес-правилами.
DELETE- самый дорогой в долгосрочной перспективе,стоимость-риск потери данных и доверия.  должны быть многоступенчатые барьеры для удаления(подтверждение
мягкое удаление,период ожидания,окончательное очищение).

Временное измерение CRUD. это само признание того что данные имеют историю.UPDATE И DELETE- стирают историю.

Event Sourcing или Immutable-ландшафт,где состояние не перезаписывается а наращивается слоями и удаление это не добавление нового события-инвалидатора.Они
хранят историю изменений как первичную истину.
то есть просто поле users с полем email переходит в состояние таблицы events, в котором каждая запись это зафиксированный факт где user зарегистрировался
потом изменил емейл и удалил запись:  UserRegistered, EmailChanged, UserDeactivated. эти поля неизменяемые и они только накапливаются.так же само
состояние почты пользователя это будет результатом действий с начала и до самого конца:
изначально пустое поле-->потом применили UserRegistered с одним email a@a.com--->потом применили UserChanged на a@b.com ----> и состояние стало{email:'a@b.com'}.
Update означает не перезапись а добавление нового события-факта.происходит не замена x на y, а z изменил атрибут x на y. и это просто фиксируется в
событии как часть контекста.
DELETE будет не удалением а добавлением события-инвалидатора. Здесь будет фиксироваться событие UserDeleted или еще как нибудь и вся предыстория
пользователя,все что происходило с аккаунтом,все изменения будет оставаться в логах навсегда. но сама сущность просто переходит в неактивное состояние. и
после если что можно добавить событие которое отменяет удаление. 
И при таком раскладе время будет становится параметром по которому можно переходить в различные состояния на любой момент из причинно-следственных фактов.
и каждое изменение будет иметь автора,временную метку,контекст и поимеет всех остальных если понадобится.
Архитектура на Запись и Чтение(CQRS). это будет просто append новой записи а чтение будет требовать построения проекций из прочитанных моделей из этих
событий для отображения в UI.Это будет намного гибче.

Состояние - это само по себе центральное понятие в CRUD.
Create - это инициализация всей  машины состояний. Я перевожу машину из абстрактного и несуществующего понятия в конкретное,физическое  и при создании items и status мы запускаем циклы с установкой начального состояния. оно может быть DRAFT (черновиком) или сразу принятым в работу(NEW).Create создает саму начальную точку на оси возможных переходов и она будет определять поведение сущности в будущем.

READ - это отдельный скриншот в моменте состояния. при запросе GET мы получаем состояние в котором находится сущность сейчас и все её  указанные атрибуты.само время формирования ответа между сервером и моментом получения клиентом всей нужной инфы- состояние может изменится и READ может давать только приближенный истину. и в таких случаях это приводит к использованию меток типа updated_at, или что-то наподобие этого.

UPDATE - будет попыткой перевода и изменения состояния сущности. при вызове PATCH мы изменяем и состояние и возможно существующие его атрибуты но, допустимо далеко не все изменения. например заказы которые уже завершены нельзя перевести в новые,потому что это будет нарушать физическую логику,либо, что либо что может нарушить финансовую отчетность,изменение цен в завершенных состояниях(заказах). 
UPDATE проверяет состояние и читает status, проверяет разрешен ли переход который мы запросили  из конкретного состояния.возможно допустимое разрешение изменения заказов в ихних состояниях через внешний конфигурируемый workflow а не if-else/,и совершение самого перехода с учетом всех побочных эффектов,например: меняется ли статус,меняются ли атрибуты,запускаются ли побочные эффекты при переходе в другое состояние и разные связные действия в других бд в соответствии с принятым решением.

DELETE - будет финальным переходом в терминальное состояние DELETED или DOES_NOT_EXIST. Но физическое удаление это само по себе стирание истории и в реальности,в реальных системах DELETE это почти всегда мягкий переход в SOFT_DELETED или INACTIVE. эти состояния такие же полноценные в машине просто из них уже нет никаких переходов обратно в активную жизнь или какое либо "воскрешение из мертвых".Он сам по себе должен проверять нет ли зависимых сущностей которые могут блокировать удаление,это  проверка ценностей. так эе выполнять каскадные переходы   для зависимых. и запускать все clean-up процессы на фоне по типу уведомлений об удалении для админов,само удаление через N дней.
TODO:  RESTORE команда.

В самом ядре для каждой сущности есть модель её состояния.
Это либо поле со статусом и типом в бд и в коде,либо таблица изменений,разрешенных в конфигурации или в бд,либо библиотека или фреймворк где объявляется состояния,переходы и колбэки. и все эти операции изменяющие сущность(CREATE,UPDATE,DELETE),система задает вопросы




Социальные аспекты CRUD:
в системе всегда работают несколько пользователей,или заангажировано несколько лиц которые связаны и другими таблицами или системами.Когда мой  Update
поля "статус заказа" триггерит уведомление для логиста,и для менеджера и включается поле начисления бонусов при оформлении n-нного количества заказов. и
например мой Delete файла может сломать ссылку в документе коллеги.и поэтому CRUD редко заканчивается на уровне одной таблицы в базе.это всегда может быть
узлом в сети процессов.
Event-Driven Architecture порождает UserUpdatedEvent,OrderDeletedEvent--->Чьи миры затронет это действие? Кого нужно уведомить? Что может сломаться? 





Для read,update и delete это обычно прочитал дважды получил то же, удалил дважды и запись уже удалена. Для Create-нет.Два одинаковых POST-запроса создадут
две одинаковые записи,в Rest для идемпотентности Update используют PUT вместо PATCH,потому что PUT заменяет весь ресурс,а PATCH частичное обновление.для
защиты от дублирования сетевые повторы, двойные клики используют idempotency keys уникальный ключ, который клиент отправляет с запросом,сервер кэширует
результат выполнения по этому ключу и на повторный запрос с тем же ключом возвращает тот же ответ, не выполняя операцию снова.
и каждая crud операция будет менять состояние системы. так же паттерны применяются для пользовательского интерфейса. валидация данных на 3х уровнях:
на клиенте(для UX)
нв уровне API(для формальной проверки типов и форматов,Pydantic схемы)
База данных будет как последний рубеж и её (ограничение которое позволяет уникально идентифицировать каждую запись в таблице) защитят от поврежденных
данных.Производительность READ зависит от индексов,каждое поле по которому происходит WHERE,ORDER BY,JOIN ----должно быть проиндексировано,но если индексы
замедляют insert i update потому что их нужно поддерживать--нужно  балансировать
Транзакционность-все связанные изменения в рамках одной операции--только в одной и единой транзакции----Списание с одного счета-зачисление на
другой---через BEGIN.....COMMIT(с read committed достаточно)

Пагинация и фильтрация — обязательная часть Read операций.

функция обновления (по id)
функция удаления (по id)

engine-глобальное подключение 
session-одно подключение конкретно
engine создаётся один раз при старте.
Session — для каждого HTTP-запроса своя.

не пишем базу данных внутри main файла. ---это будет зависимость. паттерны,сервисы,чистый код и тд..... это запрещено
отдельный database.py файл 
Презентационный слой API/UI --> бизнес-логика Services --> слой данных Repositories  --> База данных

async with session.begin(): для атомарных операций
запрещены f-строки --sql инъекции

всегда пагинация
        async def get_items(db, skip: int = 0, limit: int = 100):
    return await db.execute(
        select(Item).offset(skip).limit(limit)
    )



без пула при 100 параллельных запросах упадёт БД.
Контекстные менеджеры для сессий ---обязательно  with:

expire_on_commit=False - ставить ВСЕГДА в sessionmaker:
Без этой настройки после await session.commit() все объекты становятся неактивными.если потом обратиться к user.email -будет ошибка.
С этой настройкой- объекты остаются доступны.

await session.refresh()- после добавления нового объекта.при создании нового юзера,в объекте user, не будет id,присвоенный  от базы

lazy="raise"-ставить на отношениях в моделях

раз в месяц смотреть логи-сколько соединений в пуле, сколько ждут.
если постоянно есть ожидание-увеличить pool_size.если пул почти пустой-уменьшить.

подключение к разным бд=отдельные engine:
Если проект работает с основной БД и, например, Redis:создаю ДВА engine в database.py,два sessionmaker,две зависимости get_db() и get_redis()

В development можно без SSL, в production обязательно

В production echo=False, иначе логи забьются SQL запросами

Connection string -не хардкодить:
бкз "postgresql://user:pass@localhost/db" в коде
выносить в .env,читать через os.getenv()


При shutdown закрывать engine,атооооооо останутся незакрытые соединения
@app.on_event("shutdown")
async def shutdown():
    await engine.dispose()

datetime в UTC,все даты в бд  в UTC,конвертация в локальное время только при отображении пользователю будут проблемы с летним временем, переездами......


soft delete вместо DELETE,без удаление записи физически из бд,
сделать колонку "deleted_at" или что-то.
Удаление=проставление timestamp. 
Восстановление=очистка поля.чтобы не потерять историю данных.

Раз в неделю смотреть логи бд по медленным запросам >100ms

хэшировать перед сохранением пароли

bulk insert/update:
session.bulk_insert_mappings()-в 100 раз быстрее.


SQLAlchemy использует prepared statements их автоматически.


Если планируется нагрузка,то настроить read replicas сразу,то шо  при переделывании архитектуры будет больно.

Failover стратегия:
если основная бд упала-иметь скрипт переключения на replica.тестировать раз в квартал.


при балансе счета,настройки безопасности, для критичных данных вести лог кто и когда что изменил на уровне бд триггерами


задача connection,спит 5 минут ждёт API одновременно HTTP запросы не могут получить connection из пула в таймаут.
для фоновых задач отдельный engine с pool_size=1 или connection outside pool.


при проверке есть ли email в бд, и если нет,создаю-всего 2 запроса одновременно проверяют и видят НЕТ и оба создают. UNIQUE constraint в БД ловит, но один
пользователь получает ошибку "email уже занят", хотя только что его вводил. Надо ловить IntegrityError и retry


при long polling запросы висят 30-60 секунд забирают connection из пула. БД столько не тянет.нужно WebSockets или отдельный сервер/протокол